'use strict';
import co from 'co';

/**
 * Handling several cursors as a concatenated cursor
 */
export default class ConcatCursor{
	/**
	 * @param {Mongo.Cursor[]} stack array of cursor
	 * @param {Object} [option={}] options of sort, skip and limit
	 */
	constructor(stack, option = {}){
		const { sort, skip, limit } = option;

		/**
		 * @type {Mongo.Cursor[]}
		 */
		this.stack = stack;
		/**
		 * @type {Boolean}
		 */
		this.closed = false;
		/**
		 * sort option
		 * @type {Object} [sort={}]
		 */
		this.sort = sort || {};
		if(sort){
			if(sort.lupdt === -1 || sort.evtdt === -1 || sort.sntdt === -1){
				this.stack = this.stack.reverse();
			}
		}
		/**
		 * skip option
		 * @type {Integer} [skip=0]
		 */
		this.skip = (skip && skip > 0) ? skip : 0;
		/**
		 * limit option
		 * NOTE:
		 *   - limit = 0 means that cursor return no item
		 *
		 * @type {Integer} [limit=null]
		 */
		this.limit = limit && limit >= 0 ? limit : null;
		/**
		 * @type {Object}
		 * @property {Object} sort
		 * @property {Integer} skip
		 * @property {Integer} limit
		 */
		this.now = this.reset();
	}
	/**
	 * this method reset cursor options
	 * @return {Object}
	 */
	reset(){
		let { sort, skip, limit } = this;
		return { sort, skip, limit };
	}
	/**
	 * @param {Function} fn
	 * @return {Promise}
	 */
	each(fn){
		return mapSeries(this.stack, curr => {
			return this.applyOptions(curr).then(cursor => {
				return (cursor === null) ? null : cursor.each(fn);
			});
		}, this);
	}
	/**
	 * 各カーソル毎に count を実行し、その合計を返却する
	 * @param {Boolean} [useOptions=true]
	 * @retrun {Promise}
	 */
	count(useOptions = true){
		// For each cursor of stack run count, and return sum value
		return reduceSeries(this.stack, (prev, curr) => {
			if(useOptions){
				return this.applyOptions(curr).then(cursor => {
					return (cursor === null) ? 0 : cursor.count(true);
				}).then(cnt => prev + cnt);
			}else{
				if(curr === null){ return Promise.resolve(prev); }
				return curr.count(false).then(cnt => prev + cnt);
			}
		}, 0, this);
	}
	/**
	 * 利用可能なカーソルからすべてのデータを取得する
	 * @return {Promise[]}
	 */
	toArray(){
		return co(function *(){
			// If p is thenable, then p is yieldable.
			// So you will have result of Array by using mapSeries
			//     arr = yield mapSeries(arr, iterator);
			// <=> arr = yield [ <Promise 1>, <Promise 2>, ... ];
			// <=> arr = [ <result 1>, <result 2>, ...];
			const arr = yield mapSeries(this.stack, item => {
				return this.applyOptions(item).then(cursor => {
					if(cursor){
						let array = cursor.toArray();
						return array;
					}else{
						return [];
					}
				});
			}, this);

			//     value = yield reduceSeries(arr, iterator);
			// <=> value = yield <Promise>;
			// <=> value = <result>;
			const value = yield reduceSeries(arr, (prev, item) => {
				Array.prototype.push.apply(prev, item);
				return prev;
			}, []);
			return value;
		}.bind(this));
	}
	/**
	 * @param {Mongo.Cursor} cursor
	 * @return {Promise}
	 */
	applyOptions(cursor){
		return Promise.resolve(cursor).then(cursor => {
			let { skip, limit, sort } = this.now;

			// if this cursor equals null or its limit equals null
			// this cursor can not return item. so it is ok to return cursor is null
			if(cursor === null || cursor === undefined || limit === 0){
				return null;
			}

			// count without condition
			return cursor.count(false).then(cnt => {
				// always apply sort option to cursor
				cursor = cursor.sort(sort);

				// apply skip option to cursor
				if(skip === 0){
					// if skip === 0, skip option need not apply this cursor
				}else if(skip <= cnt){
					// if skip <= cnt, skip option need not apply after all cursors
					this.now.skip = 0;
					cursor = cursor.skip(skip);
				}else{
					// if skip > cnt, this cursor is skipped
					this.now.skip -= cnt;
					cursor = null;
					return null;
				}

				if(limit === null){
					return cursor;
				}

				// apply limit option to cursor
				if(skip + limit < cnt){
					// if skip + limit < cnt, after all cursors return no item
					this.now.limit = 0;
					cursor = cursor.limit(limit);
				}else{
					// if skip + limit >= cnt, this cursor need scan all items
					this.now.limit = limit + skip - cnt;
				}

				return cursor;
			});
		});
	}
}

/**
 * @param {Array} array
 * @param {Function} iteratee
 * @param {Object} thisArg
 * @return {Promise}
 */
let mapSeries = co.wrap(function *(array, iteratee, thisArg){
	const fn = thisArg ? iteratee.bind(thisArg) : iteratee;
	let result = [];

	for(let item of array){
		item = yield Promise.resolve(fn(item));
		result.push(item);
	}
	return result;
});

/**
 * @param {Array} array
 * @param {Function} iteratee
 * @param {Object} thisArg
 * @return {Promise}
 */
let reduceSeries = co.wrap(function *(array, iteratee, init, thisArg){
	const fn = thisArg ? iteratee.bind(thisArg) : iteratee;
	let prev = init;
	for(let curr of array){
		prev = yield Promise.resolve(fn(prev, curr));
	}
	return prev;
});
