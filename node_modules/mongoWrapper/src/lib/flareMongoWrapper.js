'use strict';
import co from 'co';
import _ from 'lodash';
import { ObjectID } from 'mongodb';
import MongoWrapper from './mongoWrapper';
import Cursor from './concatCursor';

/**
 * Export `Mongo.ObjectID` to enable find by using it.
 */
export {
	ObjectID
};

/**
 * Wrapping MongoWrapper class for FLARE
 * @extends {MongoWrapper}
 */
export default class FlareMongoWrapper extends MongoWrapper{
	/**
	 * @param {String} dbname
	 * @param {Object} criteria
	 * @param {Object} field
	 * @param {Object} opt
	 * @param {Boolean} toArray
	 * @return {Promise<ConcatCursor|Array,Error>}
	 * @ignore
	 */
	findMultipleCollection(dbname, criteria, field, opt, toArray){
		return co(function *(){
			const { _id } = criteria;
			const { prefix, date } = getPrefixAndDate(dbname);
			const { include, exclude } = createTargets(prefix, _id, date);
			let collnames = yield this.getCollectionsName(dbname, prefix, include, exclude);
			// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
			let stack = yield _.map(collnames, collname => {
				return this.find(dbname, collname, criteria, field, {});
			});
			let cursor = new Cursor(stack, opt);
			if(toArray){
				return yield cursor.toArray();
			}else{
				return cursor;
			}
		}.bind(this));
	}
	/**
	 * find from dlog.devices_xxxxxx
	 * @param {Object} criteria
	 * @param {Object} field
	 * @param {Object} opt
	 * @param {Boolean} [toArray=false]
	 * @return {Promise<ConcatCursor|Array,Error>}
	 */
	findDevice(criteria, field, opt, toArray = false){
		return this.findMultipleCollection('dlog', criteria, field, opt, toArray);
	}
	/**
	 * find from llog.location_xxxxxx
	 * @param {Object} criteria
	 * @param {Object} field
	 * @param {Object} opt
	 * @param {Boolean} [toArray=false]
	 * @return {Promise}
	 */
	findLocation(criteria, field, opt, toArray = false){
		return this.findMultipleCollection('llog', criteria, field, opt, toArray);
	}
	/**
	 * find from elog.event_xxxxxx
	 * @param {Object} criteria
	 * @param {Object} field
	 * @param {Object} opt
	 * @param {Boolean} [toArray=false]
	 * @return {Promise<ConcatCursor|Array,Error>}
	 */
	findEvent(criteria, field, opt, toArray = false){
		return this.findMultipleCollection('elog', criteria, field, opt, toArray);
	}
	/**
	 * find from clog.current
	 * @param {Object} criteria
	 * @param {Object} field
	 * @param {Object} opt
	 * @return {Promise<ConcatCursor,Error>}
	 */
	findCurrent(criteria, field, opt){
		return super.find('clog', 'current', criteria, field, opt);
	}
	/**
	 * find geo near from clog.current
	 * @param {Number[]} loc
	 * @param {Object} opt
	 * @return {Promise}
	 */
	geoNearCurrent(loc, opt = {}){
		opt.spherical = true;
		return super.geoNear('clog', 'current', loc, opt);
	}
	/**
	 * insert into dlog.devices
	 * @param {Object} doc
	 * @return {Promise}
	 */
	insertDevice(doc){
		return new Promise((resolve, reject) => {
			const { sntdt } = doc;
			const opt = { w: 1 };
			if(_.isDate(sntdt)){
				// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
				let result = this.insert('dlog', `devices_${ toYearMonth(sntdt) }`, doc, opt);
				return result.then(resolve).catch(reject);
			}else{
				return reject(new Error('sntdt must be Date'));
			}
		});
	}
	/**
	 * insert into llog.location
	 * @param {Object} doc
	 * @return {Promise}
	 */
	insertLocation(doc){
		return new Promise((resolve, reject) => {
			let { lupdt } = doc;
			let opt = { w: 1 };
			if(_.isDate(lupdt)){
				// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
				let result = this.insert('llog', `location_${ toYearMonth(lupdt) }`, doc, opt);
				return result.then(resolve).catch(reject);
			}else{
				return reject(new Error('lupdt is not Date type'));
			}
		});
	}
	/**
	 * insert into elog.event
	 * @param {Object} doc
	 * @return {Promise}
	 */
	insertEvent(doc){
		return new Promise((resolve, reject) => {
			let { evtdt } = doc;
			let opt = { w: 1 };
			if(_.isDate(evtdt)){
				// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
				let result = this.insert('elog', `event_${ toYearMonth(evtdt) }`, doc, opt);
				return result.then(resolve).catch(reject);
			}else{
				return reject(new Error('evtdt is not Date type'));
			}
		});
	}
	/**
	 * upsert into clog.current
	 * @param {Object} criteria
	 * @param {Object} doc
	 * @return {Promise}
	 */
	upsertCurrent(criteria, doc){
		let opt = { w: 1, upsert: true, multi: false };
		return super.update('clog', 'current', criteria, doc, opt);
	}
	/**
	 * get name of available collections
	 * @param {String} dbname
	 * @param {String} prefix prefix of collection name
	 * @param {String[]} include An array of include collections
	 * @param {String[]} exclude An array of exclude collections
	 * @return {Promise}
	 */
	getCollectionsName(dbname, prefix, include, exclude){
		return co(function *(){
			const filter = {
				name: new RegExp(`^${ prefix }_`)
			};
			const option = {};
			let db = yield this.getDB(dbname);
			let collections = yield db.listCollections(filter, option).toArray();
			return _.filter(_.map(collections, 'name'), name => {
				if(_.includes(exclude, name)){ return false; }
				if(_.isEmpty(include)){ return true; }
				if(_.includes(include, name)){ return true; }
				return false;
			});
		}.bind(this));
	}
	findGridFS(dbname, id, opt){
		return super.findGridFS(dbname, id, opt);
	}
	insertGridFS(dbname, buffer, opt){
		const now = Date.now();
		const rnd = Math.random().toString(16).slice(2, 5);
		const filename = `${ dbname }_${ now }_${ rnd }`;

		return super.insertGridFS(dbname, filename, buffer, opt);
		// TODO: エラー返却は、ResponseCode に変換したい。
		// return super.isnertGridFS(dbname, filename, opt).catch(e => {
		// 	info(e.stack);
		// 	const rc = new ResponseCode('1930', 'Failed to insert data');
		// 	return Promise.reject(rc);
		// });
	}
	deleteGridFS(dbname, id){
		return super.deleteGridFS(dbname, id);
	}
}

/**
 * @param {Date} [dt=new Date()]
 * @return {Integer} year and month formated `yyyymm`
 * @function
 */
function toYearMonth(dt){
	if(!_.isDate(dt)){
		dt = new Date();
	}
	return dt.getFullYear() * 100 + dt.getMonth() + 1;
}

/**
 * @param {Integer} ym year and month formated `yyyymm`
 * @return {Integer} next month formated `yyyymm`
 */
function getNextMonth(ym){
	const y = parseInt(ym / 100, 10);
	const m = ym - y * 100;
	return m % 12 ? ym + 1 : (y + 1) * 100 + 1;
}

/**
 * @param {String} prefix
 * @param {String|ObjectID} oid
 * @param {Date} date
 */
function createTargets(prefix, oid, date){
	const now = toYearMonth();
	let include = [];
	let exclude = [];
	let start, end;
	if(oid){
		const time = (new ObjectID(oid)).getTimestamp();
		start = time;
		end = time;
	}else if(date){
		start = date.$gte || date.$gt;
		end = date.$lte || date.$lt;
	}
	start = _.isDate(start) ? toYearMonth(start) : null;
	end = _.isDate(end) ? toYearMonth(end) : null;

	if(start && end){
		include = range(prefix, start, end);
	}else if(start && !end){
		include = range(prefix, start, now);
	}else if(!start && end){
		exclude = range(prefix, getNextMonth(end), now);
	}
	return { include, exclude };
}

/**
 * @param {String} prefix
 * @param {Integer} start start date formated `yyyymm`
 * @param {Integer} end end date formated `yyyymm`
 */
const range = (prefix, start, end) => {
	let months = [];
	let tmpMonth = start;
	while(tmpMonth <= end){
		months.push(`${ prefix }_${ tmpMonth }`);
		tmpMonth = getNextMonth(tmpMonth);
	}
	return months;
};

const getPrefixAndDate = dbname => {
	let date, prefix;
	switch(dbname){
		case 'dlog':
			prefix = 'devices';
			date = 'sntdt';
			break;
		case 'llog':
			prefix = 'location';
			date = 'lupdt';
			break;
		case 'elog':
			prefix = 'event';
			date = 'evtdt';
			break;
		default:
			prefix = '';
			date = 'sntdt';
			break;
	}
	return { date, prefix };
};
