'use strict';
import co from 'co';
import {
	MongoClient,
	Long,
	ObjectId,
	GridFSBucket
} from 'mongodb';
import debug from 'debug';
import { Readable } from 'stream';
import _ from 'lodash';
const info = debug('mw');

/**
 * Promise based simple wrapper of MongoDB native driver
 */
export default class MongoWrapper{
	/**
	 * @param {String} [host='localhost'] host of mongodb client
	 * @param {Number} [port=27017] port of mongodb client
	 * @param {Object} [options={}] options of mongodb client
	 */
	constructor(host = 'localhost', port = 27017, options = {}){
		/**
		 * db instances which is used already
		 * @type {Object}
		 */
		this.dbs = {};

		if(!_.isString(host)){
			throw new Error('host must be string');
		}
		/**
		 * host of mongodb client
		 * @type {String}
		 */
		this.host = host;

		if(!_.isNumber(port) || port <= 0){
			throw new Error('port must be a positive integer');
		}
		/**
		 * port of mongodb client
		 * @type {Integer}
		 */
		this.port = port;
		/**
		 * uri of mongodb client
		 * @type {String}
		 */
		this.uri = `mongodb://${ this.host }:${ this.port }`;
		/**
		 * options of mongodb client
		 * you also see { @link http://mongodb.github.io/node-mongodb-native/2.0/api/MongoClient.html }
		 * @type {Object}
		 * @property {Boolean} auto_reconnect=true
		 * @property {Boolean} native_parser=true
		 */
		this.options = options;

		this.options.auto_reconnect = true;
		this.options.native_parser = true;
	}
	/**
	 * getDB
	 * @param {String} dbname
	 * @return {Promise}
	 */
	getDB(dbname){
		const { uri, options, dbs } = this;
		if(dbname === null || dbname === undefined || dbname === ''){
			return Promise.reject(new Error('dbname is empty'));
		}
		if(!_.isString(dbname)){
			return Promise.reject(new Error('dbname must be string'));
		}
		let db = dbs[dbname];
		if(db){
			return Promise.resolve(db);
		}
		return MongoClient.connect(`${ uri }/${ dbname }`, options).then(db => {
			info(`create a instance of new db=${ dbname }`);
			this.dbs[dbname] = db;
			return db;
		});
	}
	/**
	 * getCollection
	 * @param {String} dbname
	 * @param {String} collname
	 * @return {Promise}
	 */
	getCollection(dbname, collname){
		return this.getDB(dbname).then(db => {
			if(_.isEmpty(collname)){
				return Promise.reject(new Error('collection name is empty'));
			}
			if(!_.isString(collname)){
				return Promise.reject(new Error('collection name must be string'));
			}
			return db.collection(collname);
		});
	}
	/**
	 * insert
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {Object} doc
	 * @param {Object} opt
	 * @return {Promise}
	 */
	insert(dbname, collname, doc, opt){
		return co(function *(){
			let collection = yield this.getCollection(dbname, collname);
			if(doc === null || doc === undefined || _.isString(doc)){
				return Promise.reject(new Error('document requires no empty object'));
			}
			let result = yield collection.insertOne(doc, opt);
			info('insert result=%j', result);
			return result.result;
		}.bind(this));
	}
	/**
	 * update
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {Object} criteria
	 * @param {Object} doc
	 * @param {Object} opt
	 * @return {Promise}
	 */
	update(dbname, collname, criteria, doc, opt){
		return co(function *(){
			let collection = yield this.getCollection(dbname, collname);
			let result = yield collection.updateOne(criteria, doc, opt);
			info('update result=%j', result);
			return result.result;
		}.bind(this));
	}
	/**
	 * save
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {Object} doc
	 * @param {Object} [opt = {}]
	 * @return {Promise}
	 */
	save(dbname, collname, doc, opt = {}){
		const { _id } = doc;
		if(_id){
			delete doc._id;
			return this.update(dbname, collname, { _id }, doc, opt);
		}else{
			return this.insert(dbname, collname, doc, opt);
		}
	}
	/**
	 * find
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {Object} [criteria = {}]
	 * @param {Object} [field = {}]
	 * @param {Object} [opt = {}]
	 * @return {Promise}
	 */
	find(dbname, collname, criteria = {}, field = {}, opt = {}){
		return this.getCollection(dbname, collname).then(collection => {
			return collection.find(criteria, field, opt);
		});
	}
	/**
	 * count
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {Object} [criteria = {}]
	 * @param {Object} [opt = {}]
	 * @return {Promise}
	 */
	count(dbname, collname, criteria = {}, opt = {}){
		return this.getCollection(dbname, collname).then(collection => {
			return collection.count(criteria, opt);
		});
	}
	/**
	 * geoNear
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {Number[]} loc [`<longitude>`, `<latitude>`]
	 * @param {Object} [opt = {}]
	 * @return {Promise}
	 */
	geoNear(dbname, collname, loc, opt = {}){
		return co(function *(){
			const [ x, y ] = loc;
			let collection = yield this.getCollection(dbname, collname);
			let result = yield collection.geoNear(x, y, opt);
			info('geoNear result=%j', result);
			return result.results;
		}.bind(this));
	}
	/**
	 * Insert binary data into GridFS
	 * @param {String} dbname Database name.
	 * @param {String} filename Filename.
	 * @param {Stream.Readable|Buffer} Target Data.
	 * @param {String?} [opt.metadata] Metadata of file.
	 * @param {String?} [opt.contentType] Content type of file.
	 * @param {String?} [opt.aliases] Aliases of file.
	 */
	insertGridFS(dbname, filename, data, opt){
		/**
		 * @param {Stream.Readable|Buffer} readable
		 * @param {Stream.Writable} writable
		 */
		function _finish(readable, writable){
			return new Promise((resolve, reject) => {
				const fileId = writable.id;
				if(readable instanceof Readable){
					// Readable Stream の場合
					readable.pipe(writable)
						.on('error', reject)
						.on('finish', () => resolve(fileId));
				}else if(readable instanceof Buffer){
					// Buffer の場合
					writable.end(readable);
					writable.on('error', reject);
					writable.on('finish', () => resolve(fileId));
				}else{
					return reject(new Error('data must be Buffer or Stream.Readable'));
				}
			});
		}

		return co(function *(){
			const db = yield this.getDB(dbname);
			const bucket = new GridFSBucket(db);
			const stream = bucket.openUploadStream(filename, opt);
			return yield _finish(data, stream);
		}.bind(this));
	}
	/**
	 * Find data from GridFS by using fileId
	 * @param {String} dbname
	 * @param {ObjectId|String} fileId
	 * @param {Object} opt
	 * @param {Boolean} [opt.verbose=false] Flag to return optinal data.
	 */
	findGridFS(dbname, fileId, opt = { verbose: false }){
		/**
		 * @param {Mongo.DB} db
		 * @param {ObjectId} _id
		 * @return {Object}
		 */
		function *_verbose(db, _id){
			const collname = 'fs.files';
			const opt = { limit: 1 };
			const cursor = yield this.find(dbname, collname, { _id }, {}, opt);
			return yield cursor.next();
		}

		/**
		 * _finish
		 * @param {Stream.Readable} stream
		 * @return {Object}
		 */
		function _finish(stream){
			return new Promise((resolve, reject) => {
				const fileObj = [];
				stream.on('data', chunk => fileObj.push(chunk));
				stream.on('end', () => resolve(Buffer.concat(fileObj)));
				stream.on('error', reject);
			});
		}

		return co(function *(){
			const { verbose } = opt;
			const id = convertObjectId(fileId);

			const fn = _verbose.bind(this);
			const option = verbose ? yield fn(dbname, id) : null;

			const db = yield this.getDB(dbname);
			const bucket = new GridFSBucket(db);
			const download = bucket.openDownloadStream(id);
			const data = yield _finish(download);

			return verbose ? { option, data } : { data };
		}.bind(this)).catch(err => {
			info(err.stack);
			return null;
		});
	}
	/**
	 * Delete data from GridFS by using fileId
	 * @param {String} dbname
	 * @param {ObjectId|String} fileId
	 */
	deleteGridFS(dbname, fileId){
		return co(function *(){
			const db = yield this.getDB(dbname);
			const bucket = new GridFSBucket(db);
			const id = convertObjectId(fileId);
			const ret = yield bucket.delete(id);
			info(ret);
			return true;
		}.bind(this)).catch(err => {
			info(err.stack);
			return false;
		});
	}
	/**
	 * getAutoIncrementId
	 * @param {String} dbname
	 * @param {String} collname
	 * @param {ObjectID|String} _id
	 */
	getAutoIncrementId(dbname, collname, _id){
		return co(function *(){
			const criteria = { _id };
			const doc = { $inc: { count: new Long(1) }};
			const opt = { sort: [], upsert: true, returnOriginal: false };
			let collection = yield this.getCollection(dbname, collname);
			let item = yield collection.findOneAndUpdate(criteria, doc, opt);
			return item.value.count;
		}.bind(this));
	}
}

function convertObjectId(id){
	return id instanceof ObjectId ? id : new ObjectId(id);
}
