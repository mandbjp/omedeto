'use strict';
Object.defineProperty(exports, '__esModule', {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

/**
 * Handling several cursors as a concatenated cursor
 */

var ConcatCursor = (function () {
	/**
  * @param {Mongo.Cursor[]} stack array of cursor
  * @param {Object} [option={}] options of sort, skip and limit
  */

	function ConcatCursor(stack) {
		var option = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

		_classCallCheck(this, ConcatCursor);

		var sort = option.sort;
		var skip = option.skip;
		var limit = option.limit;

		/**
   * @type {Mongo.Cursor[]}
   */
		this.stack = stack;
		/**
   * @type {Boolean}
   */
		this.closed = false;
		/**
   * sort option
   * @type {Object} [sort={}]
   */
		this.sort = sort || {};
		if (sort) {
			if (sort.lupdt === -1 || sort.evtdt === -1 || sort.sntdt === -1) {
				this.stack = this.stack.reverse();
			}
		}
		/**
   * skip option
   * @type {Integer} [skip=0]
   */
		this.skip = skip && skip > 0 ? skip : 0;
		/**
   * limit option
   * NOTE:
   *   - limit = 0 means that cursor return no item
   *
   * @type {Integer} [limit=null]
   */
		this.limit = limit && limit >= 0 ? limit : null;
		/**
   * @type {Object}
   * @property {Object} sort
   * @property {Integer} skip
   * @property {Integer} limit
   */
		this.now = this.reset();
	}

	/**
  * @param {Array} array
  * @param {Function} iteratee
  * @param {Object} thisArg
  * @return {Promise}
  */

	/**
  * this method reset cursor options
  * @return {Object}
  */

	_createClass(ConcatCursor, [{
		key: 'reset',
		value: function reset() {
			var sort = this.sort;
			var skip = this.skip;
			var limit = this.limit;

			return { sort: sort, skip: skip, limit: limit };
		}

		/**
   * @param {Function} fn
   * @return {Promise}
   */
	}, {
		key: 'each',
		value: function each(fn) {
			var _this = this;

			return mapSeries(this.stack, function (curr) {
				return _this.applyOptions(curr).then(function (cursor) {
					return cursor === null ? null : cursor.each(fn);
				});
			}, this);
		}

		/**
   * 各カーソル毎に count を実行し、その合計を返却する
   * @param {Boolean} [useOptions=true]
   * @retrun {Promise}
   */
	}, {
		key: 'count',
		value: function count() {
			var _this2 = this;

			var useOptions = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

			// For each cursor of stack run count, and return sum value
			return reduceSeries(this.stack, function (prev, curr) {
				if (useOptions) {
					return _this2.applyOptions(curr).then(function (cursor) {
						return cursor === null ? 0 : cursor.count(true);
					}).then(function (cnt) {
						return prev + cnt;
					});
				} else {
					if (curr === null) {
						return Promise.resolve(prev);
					}
					return curr.count(false).then(function (cnt) {
						return prev + cnt;
					});
				}
			}, 0, this);
		}

		/**
   * 利用可能なカーソルからすべてのデータを取得する
   * @return {Promise[]}
   */
	}, {
		key: 'toArray',
		value: function toArray() {
			return (0, _co2['default'])((function* () {
				var _this3 = this;

				// If p is thenable, then p is yieldable.
				// So you will have result of Array by using mapSeries
				//     arr = yield mapSeries(arr, iterator);
				// <=> arr = yield [ <Promise 1>, <Promise 2>, ... ];
				// <=> arr = [ <result 1>, <result 2>, ...];
				var arr = yield mapSeries(this.stack, function (item) {
					return _this3.applyOptions(item).then(function (cursor) {
						if (cursor) {
							var array = cursor.toArray();
							return array;
						} else {
							return [];
						}
					});
				}, this);

				//     value = yield reduceSeries(arr, iterator);
				// <=> value = yield <Promise>;
				// <=> value = <result>;
				var value = yield reduceSeries(arr, function (prev, item) {
					Array.prototype.push.apply(prev, item);
					return prev;
				}, []);
				return value;
			}).bind(this));
		}

		/**
   * @param {Mongo.Cursor} cursor
   * @return {Promise}
   */
	}, {
		key: 'applyOptions',
		value: function applyOptions(cursor) {
			var _this4 = this;

			return Promise.resolve(cursor).then(function (cursor) {
				var _now = _this4.now;
				var skip = _now.skip;
				var limit = _now.limit;
				var sort = _now.sort;

				// if this cursor equals null or its limit equals null
				// this cursor can not return item. so it is ok to return cursor is null
				if (cursor === null || cursor === undefined || limit === 0) {
					return null;
				}

				// count without condition
				return cursor.count(false).then(function (cnt) {
					// always apply sort option to cursor
					cursor = cursor.sort(sort);

					// apply skip option to cursor
					if (skip === 0) {
						// if skip === 0, skip option need not apply this cursor
					} else if (skip <= cnt) {
							// if skip <= cnt, skip option need not apply after all cursors
							_this4.now.skip = 0;
							cursor = cursor.skip(skip);
						} else {
							// if skip > cnt, this cursor is skipped
							_this4.now.skip -= cnt;
							cursor = null;
							return null;
						}

					if (limit === null) {
						return cursor;
					}

					// apply limit option to cursor
					if (skip + limit < cnt) {
						// if skip + limit < cnt, after all cursors return no item
						_this4.now.limit = 0;
						cursor = cursor.limit(limit);
					} else {
						// if skip + limit >= cnt, this cursor need scan all items
						_this4.now.limit = limit + skip - cnt;
					}

					return cursor;
				});
			});
		}
	}]);

	return ConcatCursor;
})();

exports['default'] = ConcatCursor;
var mapSeries = _co2['default'].wrap(function* (array, iteratee, thisArg) {
	var fn = thisArg ? iteratee.bind(thisArg) : iteratee;
	var result = [];

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var item = _step.value;

			item = yield Promise.resolve(fn(item));
			result.push(item);
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator['return']) {
				_iterator['return']();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return result;
});

/**
 * @param {Array} array
 * @param {Function} iteratee
 * @param {Object} thisArg
 * @return {Promise}
 */
var reduceSeries = _co2['default'].wrap(function* (array, iteratee, init, thisArg) {
	var fn = thisArg ? iteratee.bind(thisArg) : iteratee;
	var prev = init;
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var curr = _step2.value;

			prev = yield Promise.resolve(fn(prev, curr));
		}
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2['return']) {
				_iterator2['return']();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	return prev;
});
module.exports = exports['default'];