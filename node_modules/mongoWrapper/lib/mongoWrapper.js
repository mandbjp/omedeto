/**
 * A simple wrapper of MongoDB native driver
 * @author kawazoet14
 */

"use strict";
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var Mongo = require('mongodb');
var fs = require('fs');
var MongoClient = Mongo.MongoClient;
var Server = Mongo.Server;
var Code = Mongo.Code;
var ObjectID = Mongo.ObjectID;
var ReadPreference = Mongo.ReadPreference;
var GridStore = Mongo.GridStore;

var SEQ_COL = "Sequence";

/**
 * MongoDB Node.js driver の Wrapper Class
 * @constructor
 * @param {Object} config MongoDBサーバ設定
 * @param {Object} callback コールバック関数
 */
var MongoWrapper = module.exports = function(config, callback){
	if('function' != typeof callback){
		callback = function(){};
	}

	EventEmitter.call(this);
	var self = this;
	config = config || {};
	var host = config.host || '127.0.0.1';
	var port = config.port || Mongo.Connection.DEFAULT_PORT;
	var options = config.options || {};

	this.logger = console;

	options.auto_reconnect = true;
	options.native_parser = true;

	var mc = new MongoClient(new Server(host, port, options));
	mc.open(function(err, client){
		if(err){
			var hostname = host+':'+port;
			var errmsg = 'MongoDB connect failed:'+
				' host=['+host+':'+port+'], option=['+util.inspect(options)+']' +
				' error='+err;
			self.logger.error(errmsg);
			self.emit('connect-failed');
			callback(err);
		}else{
			self._client = client;
			self.emit('connected');
			callback(null, client);
		}
	});
};
util.inherits(MongoWrapper, EventEmitter);

/**
 * getDB
 * @param {String} dbname DB名
 * @return {Db} DB接続インスタンス
 * @private
 */
MongoWrapper.prototype.getDB = function(dbname){
	if(typeof dbname !== 'string'){
		throw new Error('dbname is string');
	}
	return this._client.db(dbname);
};

/**
 * getCollection
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @private
 */
MongoWrapper.prototype.getCollection = function(dbname, collname, callback){
	var self = this;
	try{
		this.getDB(dbname).collection(collname, callback);
	}catch(e){
		return callback(e);
	}
};

/**
 * find
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} criteria 検索条件
 * @param {Object} field フィールド条件
 * @param {Object} option オプション
 * @param {Boolean} array 結果返却を配列にするかどうか
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.find = function(dbname, collname, criteria, field, option, array, callback){
	var self = this;
	this.getCollection(dbname, collname, function(err, collection){
		if(err){
			self.logger.error(err);
			return callback(err);
		}
		if(array){
			collection.find(criteria, field, option).toArray(callback);
		}else{
			collection.find(criteria, field, option, callback);
		}
	});
};

/**
 * findById
 * _id(ObjectId) のみを検索条件にした find
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} id 検索ID
 * @param {Object} field フィールド条件
 * @param {Object} option オプション
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.findById = function(dbname, collection, id, field, option, callback){
	var self = this;
	this.getCollection(dbname, collection, function(err, collection){
		if(err){
			self.logger.error(err);
			return callback(err);
		}
		var criteria = {};
		try{
			if(id instanceof ObjectID){
				criteria._id = id;
			}else{
				criteria._id = new ObjectID(id);
			}
			collection.find(criteria, field, option, function(err, cursor){
				if(err){
					self.logger.error(err);
					return callback(err);
				}
				return cursor.nextObject(callback);
			});
		}catch(e){
			self.logger.error(e);
			return callback(e);
		}
	});
};

/**
 * findOne
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} criteria 検索ID
 * @param {Object} field フィールド条件
 * @param {Object} option オプション
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.findOne = function(dbname, collection, criteria, field, option, callback){
	var self = this;
	this.getCollection(dbname, collection, function(err, collection){
		if(err){
			return self._raiseError(err, callback);
		}
		try{
			collection.findOne(criteria, field, option, function(err, item){
				if(err){
					return self._raiseError(err, callback);
				}
				return callback(null, item);
			});
		}catch(e){
			return self._raiseError(e, callback);
		}
	});
};

/**
 * distinct
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} criteria 検索条件
 * @param {Object} key 取得キー
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.distinct = function(dbname, collection, criteria, key, callback){
	var self = this;
	this.getCollection(dbname, collection, function(err, collection){
		if(err){
			return self._raiseError(err, callback);
		}
		try{
			collection.distinct(key, criteria, function(err, keys){
				if(err){
					return self._raiseError(err, callback);
				}
				return callback(null, keys);
			});
		}catch(e){
			return self._raiseError(e, callback);
		}
	});
};

/**
 * count
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} criteria 検索条件
 * @param {Object} field フィールド条件
 * @param {Object} [option] オプション
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.count = function(dbname, collname, criteria, option, callback){
	var self = this;
	if('function' === typeof option){
		callback = option;
		option = {};
	}
	if(option === null){
		option = {};
	}
	if('function' !== typeof callback){
		callback = function(){};
	}

	this.getCollection(dbname, collname, function(err, collection){
		if(err){
			self.logger.error(err);
			return callback(err);
		}
		collection.count(criteria, option, callback);
	});
};

/**
 * insert
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} doc 登録ドキュメント
 * @param {Object} option オプション
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.insert = function(dbname, collname, doc, option, callback){
	var self = this;
	this.getCollection(dbname, collname, function(err, collection){
		if(err){
			self.logger.error(err);
			return callback(err);
		}
		collection.insert(doc, option, callback);
	});
};

/**
 * update
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} criteria 検索条件
 * @param {Object} doc 登録ドキュメント
 * @param {Object} option オプション
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.update = function(dbname, collname, criteria, doc, option, callback){
	var self = this;
	this.getCollection(dbname, collname, function(err, collection){
		if(err){
			self.logger.error(err);
			return callback(err);
		}
		collection.update(criteria, doc, option, callback);
	});
};

/**
 * save
 * @param {String} dbname DB名
 * @param {String} collname コレクション名
 * @param {Object} doc 登録ドキュメント
 * @param {Object} option オプション
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.save = function(dbname, collname, doc, option, callback){
	var self = this;
	this.getCollection(dbname, collname, function(err, collection){
		if(err){
			self.logger.error(err);
			return callback(err);
		}
		var criteria = {};
		if(doc._id){
			criteria._id = doc._id;
			collection.update(criteria, doc, option, callback);
		}else{
			collection.insert(doc, option, callback);
		}
	});
};

/**
 * writeFile
 * @param {String} dbname DB名
 * @param {String} filename ファイル名
 * @param {String} filepath ファイルパス
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.writeFile = function(dbname, filename, filepath, callback){
	var self = this;
	var db = this.getDB(dbname);
	var gs = new GridStore(db, filename, 'w', {w:1});
	gs.open(function(err, gs){
		if(err){
			self.logger.error(err);
			return callback(err);
		}else{
			gs.writeFile(filepath, function(err, writeData){
				if(err){
					self.logger.error(err);
				}
				GridStore.exist(db, filename, function(_err, fileexists){
					self.logger.info('Does %s exist ? > %s', filename, fileexists ? 'Yes': 'No');
					gs.close(callback(err, writeData));
				});
			});
		}
	});
};

/**
 * readFileStream
 * @param {String} dbname DB名
 * @param {String} filename ファイル名
 * @param {Function} callback コールバック関数
 */
MongoWrapper.prototype.readFileStream = function(dbname, filename, callback){
	var self = this;
	var db = this.getDB(dbname);
	var gs = new GridStore(db, filename, 'r', {});
	gs.open(function(err, gs){
		if(err){
			self.logger.error(err);
			return callback(err);
		}else{
			var tmp = (filename + Math.random()).replace('0.', '');
			var stream = gs.stream(true);
			stream.on('end', function(err){
				if(err){
					self.logger.error(err);
					return callback(err);
				}else{
					var streamedData = fs.createReadStream(tmp);
					var list = [];
					streamedData.on('data', function(chunk){
						list.push(chunk);
					});
					streamedData.on('end', function () {
						gs.close(callback(err, Buffer.concat(list)));
						fs.unlink(tmp);
					});
				}
			});

			var fileStream = fs.createWriteStream(tmp);
			stream.pipe(fileStream);
		}
	});
};


/**
 * _raiseError
 * @private
 */
MongoWrapper.prototype._raiseError = function(err, callback){
	if('function' == typeof callback){
		callback = function(){};
	}
	this.logger.error(err);
	return callback(err);
};

