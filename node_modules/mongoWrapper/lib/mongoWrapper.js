'use strict';
Object.defineProperty(exports, '__esModule', {
	value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _mongodb = require('mongodb');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _stream = require('stream');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var info = (0, _debug2['default'])('mw');

/**
 * Promise based simple wrapper of MongoDB native driver
 */

var MongoWrapper = (function () {
	/**
  * @param {String} [host='localhost'] host of mongodb client
  * @param {Number} [port=27017] port of mongodb client
  * @param {Object} [options={}] options of mongodb client
  */

	function MongoWrapper() {
		var host = arguments.length <= 0 || arguments[0] === undefined ? 'localhost' : arguments[0];
		var port = arguments.length <= 1 || arguments[1] === undefined ? 27017 : arguments[1];
		var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

		_classCallCheck(this, MongoWrapper);

		/**
   * db instances which is used already
   * @type {Object}
   */
		this.dbs = {};

		if (!_lodash2['default'].isString(host)) {
			throw new Error('host must be string');
		}
		/**
   * host of mongodb client
   * @type {String}
   */
		this.host = host;

		if (!_lodash2['default'].isNumber(port) || port <= 0) {
			throw new Error('port must be a positive integer');
		}
		/**
   * port of mongodb client
   * @type {Integer}
   */
		this.port = port;
		/**
   * uri of mongodb client
   * @type {String}
   */
		this.uri = 'mongodb://' + this.host + ':' + this.port;
		/**
   * options of mongodb client
   * you also see { @link http://mongodb.github.io/node-mongodb-native/2.0/api/MongoClient.html }
   * @type {Object}
   * @property {Boolean} auto_reconnect=true
   * @property {Boolean} native_parser=true
   */
		this.options = options;

		this.options.auto_reconnect = true;
		this.options.native_parser = true;
	}

	/**
  * getDB
  * @param {String} dbname
  * @return {Promise}
  */

	_createClass(MongoWrapper, [{
		key: 'getDB',
		value: function getDB(dbname) {
			var _this = this;

			var uri = this.uri;
			var options = this.options;
			var dbs = this.dbs;

			if (dbname === null || dbname === undefined || dbname === '') {
				return Promise.reject(new Error('dbname is empty'));
			}
			if (!_lodash2['default'].isString(dbname)) {
				return Promise.reject(new Error('dbname must be string'));
			}
			var db = dbs[dbname];
			if (db) {
				return Promise.resolve(db);
			}
			return _mongodb.MongoClient.connect(uri + '/' + dbname, options).then(function (db) {
				info('create a instance of new db=' + dbname);
				_this.dbs[dbname] = db;
				return db;
			});
		}

		/**
   * getCollection
   * @param {String} dbname
   * @param {String} collname
   * @return {Promise}
   */
	}, {
		key: 'getCollection',
		value: function getCollection(dbname, collname) {
			return this.getDB(dbname).then(function (db) {
				if (_lodash2['default'].isEmpty(collname)) {
					return Promise.reject(new Error('collection name is empty'));
				}
				if (!_lodash2['default'].isString(collname)) {
					return Promise.reject(new Error('collection name must be string'));
				}
				return db.collection(collname);
			});
		}

		/**
   * insert
   * @param {String} dbname
   * @param {String} collname
   * @param {Object} doc
   * @param {Object} opt
   * @return {Promise}
   */
	}, {
		key: 'insert',
		value: function insert(dbname, collname, doc, opt) {
			return (0, _co2['default'])((function* () {
				var collection = yield this.getCollection(dbname, collname);
				if (doc === null || doc === undefined || _lodash2['default'].isString(doc)) {
					return Promise.reject(new Error('document requires no empty object'));
				}
				var result = yield collection.insertOne(doc, opt);
				info('insert result=%j', result);
				return result.result;
			}).bind(this));
		}

		/**
   * update
   * @param {String} dbname
   * @param {String} collname
   * @param {Object} criteria
   * @param {Object} doc
   * @param {Object} opt
   * @return {Promise}
   */
	}, {
		key: 'update',
		value: function update(dbname, collname, criteria, doc, opt) {
			return (0, _co2['default'])((function* () {
				var collection = yield this.getCollection(dbname, collname);
				var result = yield collection.updateOne(criteria, doc, opt);
				info('update result=%j', result);
				return result.result;
			}).bind(this));
		}

		/**
   * save
   * @param {String} dbname
   * @param {String} collname
   * @param {Object} doc
   * @param {Object} [opt = {}]
   * @return {Promise}
   */
	}, {
		key: 'save',
		value: function save(dbname, collname, doc) {
			var opt = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
			var _id = doc._id;

			if (_id) {
				delete doc._id;
				return this.update(dbname, collname, { _id: _id }, doc, opt);
			} else {
				return this.insert(dbname, collname, doc, opt);
			}
		}

		/**
   * find
   * @param {String} dbname
   * @param {String} collname
   * @param {Object} [criteria = {}]
   * @param {Object} [field = {}]
   * @param {Object} [opt = {}]
   * @return {Promise}
   */
	}, {
		key: 'find',
		value: function find(dbname, collname) {
			var criteria = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
			var field = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
			var opt = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

			return this.getCollection(dbname, collname).then(function (collection) {
				return collection.find(criteria, field, opt);
			});
		}

		/**
   * count
   * @param {String} dbname
   * @param {String} collname
   * @param {Object} [criteria = {}]
   * @param {Object} [opt = {}]
   * @return {Promise}
   */
	}, {
		key: 'count',
		value: function count(dbname, collname) {
			var criteria = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
			var opt = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

			return this.getCollection(dbname, collname).then(function (collection) {
				return collection.count(criteria, opt);
			});
		}

		/**
   * geoNear
   * @param {String} dbname
   * @param {String} collname
   * @param {Number[]} loc [`<longitude>`, `<latitude>`]
   * @param {Object} [opt = {}]
   * @return {Promise}
   */
	}, {
		key: 'geoNear',
		value: function geoNear(dbname, collname, loc) {
			var opt = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

			return (0, _co2['default'])((function* () {
				var _loc = _slicedToArray(loc, 2);

				var x = _loc[0];
				var y = _loc[1];

				var collection = yield this.getCollection(dbname, collname);
				var result = yield collection.geoNear(x, y, opt);
				info('geoNear result=%j', result);
				return result.results;
			}).bind(this));
		}

		/**
   * Insert binary data into GridFS
   * @param {String} dbname Database name.
   * @param {String} filename Filename.
   * @param {Stream.Readable|Buffer} Target Data.
   * @param {String?} [opt.metadata] Metadata of file.
   * @param {String?} [opt.contentType] Content type of file.
   * @param {String?} [opt.aliases] Aliases of file.
   */
	}, {
		key: 'insertGridFS',
		value: function insertGridFS(dbname, filename, data, opt) {
			/**
    * @param {Stream.Readable|Buffer} readable
    * @param {Stream.Writable} writable
    */
			function _finish(readable, writable) {
				return new Promise(function (resolve, reject) {
					var fileId = writable.id;
					if (readable instanceof _stream.Readable) {
						// Readable Stream の場合
						readable.pipe(writable).on('error', reject).on('finish', function () {
							return resolve(fileId);
						});
					} else if (readable instanceof Buffer) {
						// Buffer の場合
						writable.end(readable);
						writable.on('error', reject);
						writable.on('finish', function () {
							return resolve(fileId);
						});
					} else {
						return reject(new Error('data must be Buffer or Stream.Readable'));
					}
				});
			}

			return (0, _co2['default'])((function* () {
				var db = yield this.getDB(dbname);
				var bucket = new _mongodb.GridFSBucket(db);
				var stream = bucket.openUploadStream(filename, opt);
				return yield _finish(data, stream);
			}).bind(this));
		}

		/**
   * Find data from GridFS by using fileId
   * @param {String} dbname
   * @param {ObjectId|String} fileId
   * @param {Object} opt
   * @param {Boolean} [opt.verbose=false] Flag to return optinal data.
   */
	}, {
		key: 'findGridFS',
		value: function findGridFS(dbname, fileId) {
			var opt = arguments.length <= 2 || arguments[2] === undefined ? { verbose: false } : arguments[2];

			/**
    * @param {Mongo.DB} db
    * @param {ObjectId} _id
    * @return {Object}
    */
			function* _verbose(db, _id) {
				var collname = 'fs.files';
				var opt = { limit: 1 };
				var cursor = yield this.find(dbname, collname, { _id: _id }, {}, opt);
				return yield cursor.next();
			}

			/**
    * _finish
    * @param {Stream.Readable} stream
    * @return {Object}
    */
			function _finish(stream) {
				return new Promise(function (resolve, reject) {
					var fileObj = [];
					stream.on('data', function (chunk) {
						return fileObj.push(chunk);
					});
					stream.on('end', function () {
						return resolve(Buffer.concat(fileObj));
					});
					stream.on('error', reject);
				});
			}

			return (0, _co2['default'])((function* () {
				var verbose = opt.verbose;

				var id = convertObjectId(fileId);

				var fn = _verbose.bind(this);
				var option = verbose ? (yield fn(dbname, id)) : null;

				var db = yield this.getDB(dbname);
				var bucket = new _mongodb.GridFSBucket(db);
				var download = bucket.openDownloadStream(id);
				var data = yield _finish(download);

				return verbose ? { option: option, data: data } : { data: data };
			}).bind(this))['catch'](function (err) {
				info(err.stack);
				return null;
			});
		}

		/**
   * Delete data from GridFS by using fileId
   * @param {String} dbname
   * @param {ObjectId|String} fileId
   */
	}, {
		key: 'deleteGridFS',
		value: function deleteGridFS(dbname, fileId) {
			return (0, _co2['default'])((function* () {
				var db = yield this.getDB(dbname);
				var bucket = new _mongodb.GridFSBucket(db);
				var id = convertObjectId(fileId);
				var ret = yield bucket['delete'](id);
				info(ret);
				return true;
			}).bind(this))['catch'](function (err) {
				info(err.stack);
				return false;
			});
		}

		/**
   * getAutoIncrementId
   * @param {String} dbname
   * @param {String} collname
   * @param {ObjectID|String} _id
   */
	}, {
		key: 'getAutoIncrementId',
		value: function getAutoIncrementId(dbname, collname, _id) {
			return (0, _co2['default'])((function* () {
				var criteria = { _id: _id };
				var doc = { $inc: { count: new _mongodb.Long(1) } };
				var opt = { sort: [], upsert: true, returnOriginal: false };
				var collection = yield this.getCollection(dbname, collname);
				var item = yield collection.findOneAndUpdate(criteria, doc, opt);
				return item.value.count;
			}).bind(this));
		}
	}]);

	return MongoWrapper;
})();

exports['default'] = MongoWrapper;

function convertObjectId(id) {
	return id instanceof _mongodb.ObjectId ? id : new _mongodb.ObjectId(id);
}
module.exports = exports['default'];