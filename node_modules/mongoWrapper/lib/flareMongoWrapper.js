'use strict';
Object.defineProperty(exports, '__esModule', {
	value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _mongodb = require('mongodb');

var _mongoWrapper = require('./mongoWrapper');

var _mongoWrapper2 = _interopRequireDefault(_mongoWrapper);

var _concatCursor = require('./concatCursor');

var _concatCursor2 = _interopRequireDefault(_concatCursor);

/**
 * Export `Mongo.ObjectID` to enable find by using it.
 */
exports.ObjectID = _mongodb.ObjectID;

/**
 * Wrapping MongoWrapper class for FLARE
 * @extends {MongoWrapper}
 */

var FlareMongoWrapper = (function (_MongoWrapper) {
	_inherits(FlareMongoWrapper, _MongoWrapper);

	function FlareMongoWrapper() {
		_classCallCheck(this, FlareMongoWrapper);

		_get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'constructor', this).apply(this, arguments);
	}

	/**
  * @param {Date} [dt=new Date()]
  * @return {Integer} year and month formated `yyyymm`
  * @function
  */

	_createClass(FlareMongoWrapper, [{
		key: 'findMultipleCollection',

		/**
   * @param {String} dbname
   * @param {Object} criteria
   * @param {Object} field
   * @param {Object} opt
   * @param {Boolean} toArray
   * @return {Promise<ConcatCursor|Array,Error>}
   * @ignore
   */
		value: function findMultipleCollection(dbname, criteria, field, opt, toArray) {
			return (0, _co2['default'])((function* () {
				var _this = this;

				var _id = criteria._id;

				var _getPrefixAndDate = getPrefixAndDate(dbname);

				var prefix = _getPrefixAndDate.prefix;
				var date = _getPrefixAndDate.date;

				var _createTargets = createTargets(prefix, _id, date);

				var include = _createTargets.include;
				var exclude = _createTargets.exclude;

				var collnames = yield this.getCollectionsName(dbname, prefix, include, exclude);
				// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
				var stack = yield _lodash2['default'].map(collnames, function (collname) {
					return _this.find(dbname, collname, criteria, field, {});
				});
				var cursor = new _concatCursor2['default'](stack, opt);
				if (toArray) {
					return yield cursor.toArray();
				} else {
					return cursor;
				}
			}).bind(this));
		}

		/**
   * find from dlog.devices_xxxxxx
   * @param {Object} criteria
   * @param {Object} field
   * @param {Object} opt
   * @param {Boolean} [toArray=false]
   * @return {Promise<ConcatCursor|Array,Error>}
   */
	}, {
		key: 'findDevice',
		value: function findDevice(criteria, field, opt) {
			var toArray = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

			return this.findMultipleCollection('dlog', criteria, field, opt, toArray);
		}

		/**
   * find from llog.location_xxxxxx
   * @param {Object} criteria
   * @param {Object} field
   * @param {Object} opt
   * @param {Boolean} [toArray=false]
   * @return {Promise}
   */
	}, {
		key: 'findLocation',
		value: function findLocation(criteria, field, opt) {
			var toArray = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

			return this.findMultipleCollection('llog', criteria, field, opt, toArray);
		}

		/**
   * find from elog.event_xxxxxx
   * @param {Object} criteria
   * @param {Object} field
   * @param {Object} opt
   * @param {Boolean} [toArray=false]
   * @return {Promise<ConcatCursor|Array,Error>}
   */
	}, {
		key: 'findEvent',
		value: function findEvent(criteria, field, opt) {
			var toArray = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

			return this.findMultipleCollection('elog', criteria, field, opt, toArray);
		}

		/**
   * find from clog.current
   * @param {Object} criteria
   * @param {Object} field
   * @param {Object} opt
   * @return {Promise<ConcatCursor,Error>}
   */
	}, {
		key: 'findCurrent',
		value: function findCurrent(criteria, field, opt) {
			return _get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'find', this).call(this, 'clog', 'current', criteria, field, opt);
		}

		/**
   * find geo near from clog.current
   * @param {Number[]} loc
   * @param {Object} opt
   * @return {Promise}
   */
	}, {
		key: 'geoNearCurrent',
		value: function geoNearCurrent(loc) {
			var opt = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

			opt.spherical = true;
			return _get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'geoNear', this).call(this, 'clog', 'current', loc, opt);
		}

		/**
   * insert into dlog.devices
   * @param {Object} doc
   * @return {Promise}
   */
	}, {
		key: 'insertDevice',
		value: function insertDevice(doc) {
			var _this2 = this;

			return new Promise(function (resolve, reject) {
				var sntdt = doc.sntdt;

				var opt = { w: 1 };
				if (_lodash2['default'].isDate(sntdt)) {
					// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
					var result = _this2.insert('dlog', 'devices_' + toYearMonth(sntdt), doc, opt);
					return result.then(resolve)['catch'](reject);
				} else {
					return reject(new Error('sntdt must be Date'));
				}
			});
		}

		/**
   * insert into llog.location
   * @param {Object} doc
   * @return {Promise}
   */
	}, {
		key: 'insertLocation',
		value: function insertLocation(doc) {
			var _this3 = this;

			return new Promise(function (resolve, reject) {
				var lupdt = doc.lupdt;

				var opt = { w: 1 };
				if (_lodash2['default'].isDate(lupdt)) {
					// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
					var result = _this3.insert('llog', 'location_' + toYearMonth(lupdt), doc, opt);
					return result.then(resolve)['catch'](reject);
				} else {
					return reject(new Error('lupdt is not Date type'));
				}
			});
		}

		/**
   * insert into elog.event
   * @param {Object} doc
   * @return {Promise}
   */
	}, {
		key: 'insertEvent',
		value: function insertEvent(doc) {
			var _this4 = this;

			return new Promise(function (resolve, reject) {
				var evtdt = doc.evtdt;

				var opt = { w: 1 };
				if (_lodash2['default'].isDate(evtdt)) {
					// XXX super を利用したいが、関数の中で、super を利用すると syntax error になる
					var result = _this4.insert('elog', 'event_' + toYearMonth(evtdt), doc, opt);
					return result.then(resolve)['catch'](reject);
				} else {
					return reject(new Error('evtdt is not Date type'));
				}
			});
		}

		/**
   * upsert into clog.current
   * @param {Object} criteria
   * @param {Object} doc
   * @return {Promise}
   */
	}, {
		key: 'upsertCurrent',
		value: function upsertCurrent(criteria, doc) {
			var opt = { w: 1, upsert: true, multi: false };
			return _get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'update', this).call(this, 'clog', 'current', criteria, doc, opt);
		}

		/**
   * get name of available collections
   * @param {String} dbname
   * @param {String} prefix prefix of collection name
   * @param {String[]} include An array of include collections
   * @param {String[]} exclude An array of exclude collections
   * @return {Promise}
   */
	}, {
		key: 'getCollectionsName',
		value: function getCollectionsName(dbname, prefix, include, exclude) {
			return (0, _co2['default'])((function* () {
				var filter = {
					name: new RegExp('^' + prefix + '_')
				};
				var option = {};
				var db = yield this.getDB(dbname);
				var collections = yield db.listCollections(filter, option).toArray();
				return _lodash2['default'].filter(_lodash2['default'].map(collections, 'name'), function (name) {
					if (_lodash2['default'].includes(exclude, name)) {
						return false;
					}
					if (_lodash2['default'].isEmpty(include)) {
						return true;
					}
					if (_lodash2['default'].includes(include, name)) {
						return true;
					}
					return false;
				});
			}).bind(this));
		}
	}, {
		key: 'findGridFS',
		value: function findGridFS(dbname, id, opt) {
			return _get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'findGridFS', this).call(this, dbname, id, opt);
		}
	}, {
		key: 'insertGridFS',
		value: function insertGridFS(dbname, buffer, opt) {
			var now = Date.now();
			var rnd = Math.random().toString(16).slice(2, 5);
			var filename = dbname + '_' + now + '_' + rnd;

			return _get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'insertGridFS', this).call(this, dbname, filename, buffer, opt);
			// TODO: エラー返却は、ResponseCode に変換したい。
			// return super.isnertGridFS(dbname, filename, opt).catch(e => {
			// 	info(e.stack);
			// 	const rc = new ResponseCode('1930', 'Failed to insert data');
			// 	return Promise.reject(rc);
			// });
		}
	}, {
		key: 'deleteGridFS',
		value: function deleteGridFS(dbname, id) {
			return _get(Object.getPrototypeOf(FlareMongoWrapper.prototype), 'deleteGridFS', this).call(this, dbname, id);
		}
	}]);

	return FlareMongoWrapper;
})(_mongoWrapper2['default']);

exports['default'] = FlareMongoWrapper;
function toYearMonth(dt) {
	if (!_lodash2['default'].isDate(dt)) {
		dt = new Date();
	}
	return dt.getFullYear() * 100 + dt.getMonth() + 1;
}

/**
 * @param {Integer} ym year and month formated `yyyymm`
 * @return {Integer} next month formated `yyyymm`
 */
function getNextMonth(ym) {
	var y = parseInt(ym / 100, 10);
	var m = ym - y * 100;
	return m % 12 ? ym + 1 : (y + 1) * 100 + 1;
}

/**
 * @param {String} prefix
 * @param {String|ObjectID} oid
 * @param {Date} date
 */
function createTargets(prefix, oid, date) {
	var now = toYearMonth();
	var include = [];
	var exclude = [];
	var start = undefined,
	    end = undefined;
	if (oid) {
		var time = new _mongodb.ObjectID(oid).getTimestamp();
		start = time;
		end = time;
	} else if (date) {
		start = date.$gte || date.$gt;
		end = date.$lte || date.$lt;
	}
	start = _lodash2['default'].isDate(start) ? toYearMonth(start) : null;
	end = _lodash2['default'].isDate(end) ? toYearMonth(end) : null;

	if (start && end) {
		include = range(prefix, start, end);
	} else if (start && !end) {
		include = range(prefix, start, now);
	} else if (!start && end) {
		exclude = range(prefix, getNextMonth(end), now);
	}
	return { include: include, exclude: exclude };
}

/**
 * @param {String} prefix
 * @param {Integer} start start date formated `yyyymm`
 * @param {Integer} end end date formated `yyyymm`
 */
var range = function range(prefix, start, end) {
	var months = [];
	var tmpMonth = start;
	while (tmpMonth <= end) {
		months.push(prefix + '_' + tmpMonth);
		tmpMonth = getNextMonth(tmpMonth);
	}
	return months;
};

var getPrefixAndDate = function getPrefixAndDate(dbname) {
	var date = undefined,
	    prefix = undefined;
	switch (dbname) {
		case 'dlog':
			prefix = 'devices';
			date = 'sntdt';
			break;
		case 'llog':
			prefix = 'location';
			date = 'lupdt';
			break;
		case 'elog':
			prefix = 'event';
			date = 'evtdt';
			break;
		default:
			prefix = '';
			date = 'sntdt';
			break;
	}
	return { date: date, prefix: prefix };
};