'use strict';
import assert from 'power-assert';
import { default as MongoWrapper } from '../lib/mongoWrapper';
import co from 'co';

/** @test MongoWrapper */
describe('MongoWrapper', () => {
	/** @test MongoWrapper#constructor */
	describe('constructor', () => {
		it('3 arguments, all paramaters is correct', done => {
			try{
				let mongo = new MongoWrapper('localhost.local', 27018, { poolSize: 10 });
				assert.equal(mongo.host, 'localhost.local');
				assert.equal(mongo.port, 27018);
				assert.equal(mongo.uri, 'mongodb://localhost.local:27018');
				assert.deepEqual(mongo.dbs, {});
				assert.deepEqual(mongo.options, {
					auto_reconnect: true,
					native_parser: true,
					poolSize: 10
				});
				done();
			}catch(e){
				done(e);
			}
		});
		it('3 arguments, 3rd paramater is incorrect (string)', done => {
			try{
				const m = new MongoWrapper('localhost.local', 27018, 'options');
				noop(m);
				done(new Error('all passes'));
			}catch(e){
				done();
			}
		});
		it('2 arguments, all paramaters is correct', done => {
			try{
				let mongo = new MongoWrapper('localhost.local', 27018);
				assert.equal(mongo.host, 'localhost.local');
				assert.equal(mongo.port, 27018);
				assert.equal(mongo.uri, 'mongodb://localhost.local:27018');
				assert.deepEqual(mongo.dbs, {});
				assert.deepEqual(mongo.options, {
					auto_reconnect: true,
					native_parser: true
				});
				done();
			}catch(e){
				done(e);
			}
		});
		it('2 arguments, 2nd paramater is incorrect (string)', done => {
			try{
				const m = new MongoWrapper('localhost.local', 'test');
				noop(m);
				done(new Error('all passes'));
			}catch(e){
				assert.equal('port must be a positive integer', e.message);
				done();
			}
		});
		it('2 arguments, 2nd paramater is incorrect (nagative int)', done => {
			try{
				const m = new MongoWrapper('localhost.local', -1);
				noop(m);
				done(new Error('all passes'));
			}catch(e){
				assert.equal('port must be a positive integer', e.message);
				done();
			}
		});
		it('1 argument,  all paramaters is correct', done => {
			try{
				let mongo = new MongoWrapper('localhost.local');
				assert.equal(mongo.host, 'localhost.local');
				assert.equal(mongo.port, 27017);
				assert.equal(mongo.uri, 'mongodb://localhost.local:27017');
				assert.deepEqual(mongo.dbs, {});
				assert.deepEqual(mongo.options, {
					auto_reconnect: true,
					native_parser: true
				});
				done();
			}catch(e){
				done(e);
			}
		});
		it('1 argument,  1st paramater is incorrect (object)', done => {
			try{
				const m = new MongoWrapper({ test: true });
				noop(m);
				done(new Error('all passes'));
			}catch(e){
				assert.equal('host must be string', e.message);
				done();
			}
		});
		it('0 argument', done => {
			try{
				let mongo = new MongoWrapper();
				assert.equal(mongo.host, 'localhost');
				assert.equal(mongo.port, 27017);
				assert.equal(mongo.uri, 'mongodb://localhost:27017');
				assert.deepEqual(mongo.dbs, {});
				assert.deepEqual(mongo.options, {
					auto_reconnect: true,
					native_parser: true
				});
				done();
			}catch(e){
				done(e);
			}
		});
	});

	/** @test MongoWrapper#getDB */
	describe('getDB(dbname)', () => {
		let mongo = new MongoWrapper();
		beforeEach(done => {
			mongo.dbs = {};
			done();
		});
		afterEach(done => {
			done();
		});
		it('dbname = testdb', done => {
			mongo.getDB('testdb').then(db => {
				assert(db === mongo.dbs['testdb']);
				done();
			}).catch(done);
		});
		it('dbname = <null>', done => {
			mongo.getDB(null).then(db => {
				done(new Error('all passed'));
			}, err => {
				assert.equal(err.message, 'dbname is empty');
				done();
			});
		});
		it('dbname = <undefined>', done => {
			mongo.getDB().then(db => {
				done(new Error('all passed'));
			}, err => {
				assert.equal(err.message, 'dbname is empty');
				done();
			});
		});
		it('dbname = <empty string>', done => {
			mongo.getDB('').then(db => {
				done(new Error('all passed'));
			}, err => {
				assert.equal(err.message, 'dbname is empty');
				done();
			});
		});
		it('dbname = <object>', done => {
			mongo.getDB({}).then(db => {
				done(new Error('all passed'));
			}, err => {
				assert.equal(err.message, 'dbname must be string');
				done();
			});
		});
	});

	/** @test MongoWrapper#getCollection */
	describe('getCollection(dbname, collname)', () => {
		let mongo = new MongoWrapper();
		beforeEach(done => {
			mongo.dbs = {};
			done();
		});
		afterEach(done => {
			done();
		});
		it('dbname is incorrect (object)', done => {
			mongo.getCollection({}, 'test').then(collection => {
				done(new Error('all passed'));
			}, err => {
				assert.equal(err.message, 'dbname must be string');
				done();
			});
		});
		it('collname = test', done => {
			mongo.getCollection('testdb', 'test').then(collection => {
				done();
			}, err => {
				done(err);
			});
		});
		it('collname = <null>', done => {
			mongo.getCollection('testdb', null).then(collection => {
				done(new Error('all passed'));
			}, err => {
				assert.equal('collection name is empty', err.message);
				done();
			}).catch(err => {
				done(err);
			});
		});
		it('collname = <undefined>', done => {
			mongo.getCollection('testdb', undefined).then(collection => {
				done(new Error('all passed'));
			}, err => {
				assert.equal('collection name is empty', err.message);
				done();
			}).catch(err => {
				done(err);
			});
		});
		it('collname = <empty string>', done => {
			mongo.getCollection('testdb', '').then(collection => {
				done(new Error('all passed'));
			}, err => {
				assert.equal('collection name is empty', err.message);
				done();
			}).catch(err => {
				done(err);
			});
		});
		it('collname = <object>', done => {
			mongo.getCollection('testdb', { test: 'test' }).then(collection => {
				done(new Error('all passed'));
			}, err => {
				assert.equal(err.message, 'collection name must be string');
				done();
			}).catch(err => {
				done(err);
			});
		});
	});
	/** @test MongoWrapper#insert */
	describe('insert(doc, opt)', () => {
		let mongo = new MongoWrapper();
		beforeEach(done => {
			done();
		});
		afterEach(done => {
			mongo.getDB('testdb').then(db => db.dropCollection('test'));
			done();
		});
		[ null, undefined, '', 'string', { w: 1 } ].forEach(item => {
			const str = item === '' ? 'empty string' : item;
			it(`opt is <${ str }>`, done => {
				mongo.insert('testdb', 'test', { n: 1 }, item).then(ret1 => {
					assert.equal(ret1.ok, 1);
					assert.equal(ret1.n, 1);
					done();
				}).catch(e => {
					done(e);
				});
			});
		});
		[ null, undefined, '', 'string' ].forEach(item => {
			const str = item === '' ? 'empty string' : item;
			it(`doc is <${ str }>`, done => {
				mongo.insert('testdb', 'test', item, { w: 1 }).then(ret1 => {
					done(new Error('all passed'));
				}, err => {
					assert.equal(err.message, `document requires no empty object`);
					done();
				}).catch(e => {
					done(e);
				});
			});
		});
		[ {}, { n: 12345 }].forEach(item => {
			it(`doc is <object> (${ JSON.stringify(item) })`, done => {
				mongo.insert('testdb', 'test', item, { w: 1 }).then(ret1 => {
					assert.equal(ret1.ok, 1);
					assert.equal(ret1.n, 1);
					done();
				}).catch(e => {
					done(e);
				});
			});
		});
		it('doc is <object> with no existed _id', done => {
			mongo.insert('testdb', 'test', { _id: 1 }).then(ret1 => {
				assert.equal(ret1.ok, 1);
				assert.equal(ret1.n, 1);
				done();
			}).catch(e => {
				done(e);
			});
		});
		it('doc is <object> with existed _id', done => {
			mongo.insert('testdb', 'test', { _id: 1 }).then(ret1 => {
				return mongo.insert('testdb', 'test', { _id: 1 }).then(ret2 => {
					done(new Error('all passed'));
				}, err => {
					assert.equal('MongoError', err.name);
					assert.equal(11000, err.code);
					done();
				});
			}).catch(e => {
				done(e);
			});
		});
	});
	/** @test MongoWrapper#find */
	describe('find(query, field, opt)', () => {
		let mongo = new MongoWrapper();
		beforeEach(done => {
			mongo.dbs = {};
			co(function *(){
				for(let ii = 0; ii < 15; ii++){
					const doc = { i: ii, n: 10, p: { t: 1 } };
					yield mongo.insert('testdb', 'test', doc, { w: 1 });
				}
			}).then(() => {
				done();
			});
		});
		afterEach(done => {
			mongo.getDB('testdb').then(db => db.dropCollection('test'));
			done();
		});
		it('query n = 10', () => {
			return co(function *(){
				let cursor = yield mongo.find('testdb', 'test', { n: 10 }, {}, {});
				let items = yield cursor.toArray();
				assert.equal(items.length, 15);
				assert.equal(items[0].n, 10);
				assert.equal(items[0].p.t, 1);
			});
		});
		it('query i < 5', () => {
			return co(function *(){
				let cursor = yield mongo.find('testdb', 'test', { i: { $lt: 5 } }, {}, {});
				let items = yield cursor.toArray();
				assert.equal(items.length, 5);
				assert.equal(items[0].n, 10);
				assert.equal(items[0].p.t, 1);
			});
		});
		it('field only i', () => {
			return co(function *(){
				let cursor = yield mongo.find('testdb', 'test', { i: 1 }, { i: 1 }, {});
				let items = yield cursor.toArray();
				assert.equal(items.length, 1);
				assert.equal(items[0].i, 1);
				assert.equal(items[0].n, undefined);
				assert.equal(items[0].p, undefined);
			});
		});
		it('opt is { limit: 5 }', () => {
			return co(function *(){
				const option = { limit: 5 };
				let cursor = yield mongo.find('testdb', 'test', {}, {}, option);
				let items = yield cursor.toArray();
				assert.equal(items.length, 5);
				for(let i = 0; i < 5; i++){
					assert.equal(items[i].i, i);
				}
				return;
			});
		});
		it('opt is { skip: 5 }', () => {
			return co(function *(){
				const option = { skip: 5 };
				let cursor = yield mongo.find('testdb', 'test', {}, {}, option);
				let items = yield cursor.toArray();
				assert.equal(items.length, 10);
				for(let i = 0; i < 10; i++){
					assert.equal(items[i].i, i + 5);
				}
				return;
			});
		});
		it('opt is { skip: 5, limit: 5 }', () => {
			return co(function *(){
				const option = { skip: 5, limit: 5 };
				let cursor = yield mongo.find('testdb', 'test', {}, {}, option);
				let items = yield cursor.toArray();
				assert.equal(items.length, 5);
				for(let i = 0; i < 5; i++){
					assert.equal(items[i].i, i + 5);
				}
				return;
			});
		});
	});
	/** @test MongoWrapper#count */
	describe('count(query)', () => {
		let mongo = new MongoWrapper();
		beforeEach(done => {
			mongo.dbs = {};
			co(function *(){
				for(let ii = 0; ii < 15; ii++){
					const doc = { i: ii, n: 10, p: { t: 1 } };
					yield mongo.insert('testdb', 'test', doc, { w: 1 });
				}
			}).then(() => {
				done();
			});
		});
		afterEach(done => {
			mongo.getDB('testdb').then(db => db.dropCollection('test'));
			done();
		});
		it('query i < 5', () => {
			return co(function *(){
				let count = yield mongo.count('testdb', 'test', { i: { $lt: 5 } }, {}, {});
				assert.equal(count, 5);
			});
		});
	});
	/** @test MongoWrapper#update */
	describe('update(query, doc)', () => {
		let mongo = new MongoWrapper();
		beforeEach(done => {
			mongo.dbs = {};
			co(function *(){
				let doc1 = { a: 1, b: 2, c: { d: 3 }, e: 4 };
				yield mongo.insert('testdb', 'test', doc1, { w: 1 });
				let doc2 = { a: 1, b: 2, c: { d: 3 }, e: 5 };
				yield mongo.insert('testdb', 'test', doc2, { w: 1 });
			}).then(() => done());
		});
		afterEach(done => {
			mongo.getDB('testdb').then(db => db.dropCollection('test'));
			done();
		});
		it('query { e: 4 }, doc = { b: 20 }', () => {
			return co(function *(){
				const query = { e: 4 };
				const doc = { $set: { b: 20 }};
				let ret = yield mongo.update('testdb', 'test', query, doc);
				assert.equal(ret.ok, 1);
				assert.equal(ret.n, 1);
			});
		});
		it('query { e: 4 }, doc = { c: { d: 20} }', () => {
			return co(function *(){
				const query = { e: 4 };
				const doc = { $set: { 'c.d': 20 }};
				let ret = yield mongo.update('testdb', 'test', query, doc);
				assert.equal(ret.ok, 1);
				assert.equal(ret.n, 1);
			});
		});
		it('query { a: 1 }, doc = { b: 20 }', () => {
			return co(function *(){
				const query = { a: 1 };
				const doc = { $set: { b: 20 }};
				let ret = yield mongo.update('testdb', 'test', query, doc);
				assert.equal(ret.ok, 1);
				assert.equal(ret.n, 1);
			});
		});
	});
	/** @test MongoWrapper#save */
	describe('save(query, doc)', () => {
	});
});

let noop = v => {
	return;
};
