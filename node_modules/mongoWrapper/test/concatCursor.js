'use strict';
import assert from 'power-assert';
import ConcatCursor from '../lib/concatCursor';
import { default as MongoWrapper } from '../lib/mongoWrapper';
import co from 'co';

/** @test ConcatCursor */
describe('ConcatCursor', () => {
	let stack;
	let mongo = new MongoWrapper();
	before(done => {
		co(function *(){
			for(let ii = 0; ii < 10; ii++){
				const doc = { i: ii, p: ii * ii, sntdt: ii };
				yield mongo.insert('testdb', 'con1', doc, { w: 1 });
			}
			for(let ii = 10; ii < 20; ii++){
				const doc = { i: ii, p: ii * ii, sntdt: ii };
				yield mongo.insert('testdb', 'con2', doc, { w: 1 });
			}
			done();
		});
	});
	after(done => {
		co(function *(){
			let db = yield mongo.getDB('testdb');
			yield db.dropCollection('con1');
			yield db.dropCollection('con2');
			done();
		});
	});
	beforeEach(done => {
		co(function *(){
			let con1 = yield mongo.find('testdb', 'con1', {}, {}, {});
			let con2 = yield mongo.find('testdb', 'con2', {}, {}, {});
			stack = [ con1, con2 ];
			done();
		});
	});
	afterEach(done => {
		stack = [];
		done();
	});
	/** @test ConcatCursor#constructor */
	describe('constructor', () => {
		it('option: skip, limit, sort(asc)', () => {
			const option = { skip: 3, limit: 4, sort: { sntdt: 1 }};
			const cursors = new ConcatCursor(stack, option);
			assert.equal(cursors.skip, option.skip);
			assert.equal(cursors.limit, option.limit);
			assert.equal(cursors.sort, option.sort);
			assert.equal(cursors.stack.length, 2);
		});
		it('option: skip, limit, sort(dsc)', () => {
			const option = { skip: 3, limit: 4, sort: { sntdt: -1 }};
			const cursors = new ConcatCursor(stack, option);
			assert.equal(cursors.skip, option.skip);
			assert.equal(cursors.limit, option.limit);
			assert.equal(cursors.sort, option.sort);
			assert.equal(cursors.stack.length, 2);
		});
	});
	/** @test ConcatCursor#toArray() */
	describe('toArray()', () => {
		it('no option', () => {
			return co(function *(){
				let cursor = new ConcatCursor(stack, {});
				let items = yield cursor.toArray();
				assert.equal(items.length, 20);
				for(let ii = 0; ii < 20; ii++){
					assert.equal(items[ii].i, ii);
					assert.equal(items[ii].p, ii * ii);
				}
				return;
			});
		});
		it('option: skip', () => {
			return co(function *(){
				let cursor = new ConcatCursor(stack, { skip: 5 });
				let items = yield cursor.toArray();
				assert.equal(items.length, 15);
				for(let ii = 0; ii < 15; ii++){
					const jj = ii + 5;
					assert.equal(items[ii].i, jj);
					assert.equal(items[ii].p, jj * jj);
				}
				return;
			});
		});
		it('option: limit', () => {
			return co(function *(){
				let cursor = new ConcatCursor(stack, { limit: 15 });
				let items = yield cursor.toArray();
				assert.equal(items.length, 15);
				for(let ii = 0; ii < 15; ii++){
					assert.equal(items[ii].i, ii);
					assert.equal(items[ii].p, ii * ii);
				}
				return;
			});
		});
		it('option: sort(dsc)', () => {
			return co(function *(){
				let cursor = new ConcatCursor(stack, { sort: { sntdt: -1 }});
				let items = yield cursor.toArray();
				assert.equal(items.length, 20);
				for(let ii = 0; ii < 20; ii++){
					const jj = 19 - ii;
					assert.equal(items[ii].i, jj);
					assert.equal(items[ii].p, jj * jj);
				}
				return;
			});
		});
		it('option: skip, limit', () => {
			return co(function *(){
				const option = { skip: 5, limit: 10, sort: {}};
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.toArray();
				assert.equal(items.length, option.limit);
				for(let ii = 0; ii < option.limit; ii++){
					const jj = ii + option.skip;
					const kk = option.sort.sntdt === -1 ? 20 - jj - 1 : jj;
					assert.equal(items[ii].i, kk);
					assert.equal(items[ii].p, kk * kk);
				}
				return;
			});
		});
		it('option: skip, limit, sort(dsc)', () => {
			return co(function *(){
				const option = { skip: 6, limit: 10, sort: { sntdt: -1 }};
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.toArray();
				assert.equal(items.length, option.limit);
				for(let ii = 0; ii < option.limit; ii++){
					const jj = ii + option.skip;
					const kk = option.sort.sntdt === -1 ? 20 - jj - 1 : jj;
					assert.equal(items[ii].i, kk);
					assert.equal(items[ii].p, kk * kk);
				}
				return;
			});
		});
	});
	/** @test ConcatCursor#count() */
	describe('count()', () => {
		it('no option', () => {
			return co(function *(){
				const option = {};
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count();
				assert.equal(items, 20);
			});
		});
		it('option: skip', () => {
			return co(function *(){
				const option = { skip: 5 };
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count();
				assert.equal(items, 20 - option.skip);
			});
		});
		it('option: limit', () => {
			return co(function *(){
				const option = { limit: 5 };
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count();
				assert.equal(items, option.limit);
			});
		});
		it('option: sort(dsc)', () => {
			return co(function *(){
				const option = { sort: { sntdt: -1 }};
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count();
				assert.equal(items, 20);
			});
		});
		it('option: skip, limit', () => {
			return co(function *(){
				const option = { skip: 5, limit: 10 };
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count();
				assert.equal(items, option.limit);
			});
		});
		it('option: skip, limit', () => {
			return co(function *(){
				const option = { skip: 10, limit: 15 };
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count(true);
				assert.equal(items, 10);
			});
		});
		it('no apply option', () => {
			return co(function *(){
				const option = { skip: 10, limit: 15 };
				let cursor = new ConcatCursor(stack, option);
				let items = yield cursor.count(false);
				assert.equal(items, 20);
			});
		});
	});
});
